双向沟通

1. 自我介绍（学习方面、项目实践、未来规划）

您好，我叫，毕业于广西机电职业技术学院，就读的是计算机应用技术专业，今天主来我们公司面试web前端岗位

我从三个点来介绍自己吧

学习方面：

我在学校主修的是计算机应用技术，选择这个专业的原因是自己高中时期就对计算机有浓厚的兴趣，在最开始的学习中，主要是PS切图还有构建一些静态页面，刚开始感觉自己能做出一些页面感觉很久成就感，后面就慢慢入坑了，哈哈，再后来的话就是参加一些网页设计大赛，这让那是前端知识匮乏的我，慢慢充实了前端的知识

在项目方面：

目前是有过两份工作经验，最开始接触的是jQuery做一些页面，也有写过一些H5还有一些响应式布局的页面，最近接触的项目就是《美丽湾》《顺丰的当家》的电商网站，还有一些就是关于小程序的一些项目

在未来规划方面：

就目前来说的话我们前端这方面的技术更新还是挺快的，我对自己的要求就是，先把现阶段流行的一些前端技术（比如vue react这些）先沉淀好，然后有机会的话就把后端的node、php也研究好，最后的话当然是希望自己能做个全栈工程师，在某些方面也能独挡一面，当然这是比较长远的计划了


2. 你为什么想走前端？



3. 为什么来广州

    1.我是学IT的，一定要来XX城市，这个城市的机会更多，薪资也不错，我还年轻，想给自己几年的时间锻炼一下。

    2.我一直想来这个城市生活，大学期间就做了很多的准备，打工存钱，实习……现在自己一个人生活是没有问题的。

    3.我的亲戚/朋友在这里，我会和他们一起住，生活上有个照顾比较方便。爸妈也放心。

    4.我和男/女朋友恋爱多年已经有结婚的打算，我们打算在这里结婚定居。




4. 本身对前端就感兴趣吗？


5. 学前端多久了？


6. 有没有一些自己的作品


7. 有没有使用git（区别与GitHub）


8. 有没有自己的一些资料库


9. 你可以配合加班吗？

    + 自己技术问题
    + 工作协调问题

    跟技术主管讨论项目进度情况怎么样，对比自己的投入是否能够满足项目的进度，是否存在自己效率不好，或是项目进度过快(从而调正自己的工作进度)

    加班是工作变成没有效率的结果


10. 未来规划或想学习的技术


11. 接触后端（node、php、mysql）


12. 使用jq去监测使用者的状态来反馈一些动画效果（信息）


13. jq有哪些api（history API、监测网速的API）


14. 有没有跟设计师合作过的经验（或后端）


15. 有用过那些线上服务（GitHub gitee gitlab svnbucket）


16. extjs 


17. 有没有在同一个页面同时接过 二三十个 API 的经验

没有，如果是这样的话 我觉得该跟后端商量一下是否接口设计的有问题了


18. rest API  restful


19. 作品/学习（项目/研究api）


20. 对自己学习的计划（详细） （公司希望能达到怎么样的一种成程度）


21. MVC framework (Angular/Ember)  MVVM 


22. 了解 Google Analytics(GA)  Facebook Pixel SEO


23. 被问到不会的题目如何应答（习惯把你问倒或者了解你的技术程度）

    这部分我没有涉略，（以前公司没有需要到这方面的技术）如果公司需要（这方面的技术）的话，我可以`研究`(切记勿用学习字眼)它的API 文档 
    
    （如果你很喜歡特定公司，可以把問題記下來，回到家研究完後，再發個感謝信給面試官，順道將解法回傳給對方，自然會對你印象加分）


24. 有用过数据库吗？（后端语言）


25. 浏览器兼容性


26. 物件导向写js


27. 你对我们公司了解多少


28. 还有哪些mvvm框架啊？


29. 你读过jQuery源码吗？

    1、所有的工作都是在一个匿名函数内执行，保证了命名空间的安全
　　2、使用了工厂模式构建的类
　　3、jQuery有一个叫extend的方法，jQuery所有方法属性都是使用此方法扩展出来的
　　4、使用的方法分两大类，全局方法类和实例方法类，他们都有自己的对应的扩展入口




100. 准备至少十个问题询问公司状况（公司在面试你，你也在面试公司）

    请问公司的部门架构怎么样？

    技术部门协作流程是如何？

    现阶段前端主要负责哪些项目？（项目周期如何）

    项目主要是开发 还是维护  还是一半一半？

    公司预期将来会用到那些主流的技术？

    你们如何考量个人绩效？（年终福利如何？是否会影响到年终福利？）

    使用什么版本空制工具？

    技术部门都用那些技术（框架）、工具、服务(代码管理)？

    公司社保如何交，五险一金

    公司组成部分

    公司最稳定的成熟的产品

    上线测试

    公司那个季度比较忙？（轻）

    我要负责内容是什么（项目是什么）

    是否还有其他竞争者 与他们相差如何

    我希望后续能得到不录取的原因，能及时改进

    公司的发展方向

    团队目前最大的挑战是什么

    你们会做正式的绩效评估吗？

        就像一个人学习一样 看到自己的成绩 会比较有动力
        或者不足的去弥补
        不至于只会无脑的codeing

    公司多久会做一次团队总结、回顾

    跟我谈谈公司的文化





    作用域：

        全局变量和局部变量

        最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的

        局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的

        函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

        只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”（变量提升）

        var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。
        let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
        const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。

    作用域链：

        根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。


    原型链：

        简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。


    原型对象：

        JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object 、Function 是 JS 自带的函数对象




    闭包：

        闭包就是能够读取其他函数内部变量的函数

        闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域

        闭包的特性：

        函数内再嵌套函数
        内部函数可以引用外层的参数和变量
        参数和变量不会被垃圾回收机制回收


        用闭包方式解决了变量污染问题，闭包内返回模块对象，只需对外暴露一个全局变量。

        闭包有两个作用： 
        第一个就是可以读取自身函数外部的变量（沿着作用域链寻找） 
        第二个就是让这些外部变量始终保存在内存中 

        好处：能够实现封装和缓存等；

        坏处：就是消耗内存、不正当使用会造成内存溢出的问题


    变量访问规则：

        变量访问就像一座大楼一样，函数会从当前楼层先找，也就是局部变量，找不到就乘着电梯往上找，依次向上，直到顶楼，也就是全局变量

    事件代理（事件委托）
        “事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能

        可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒
        可以实现当新增子对象时无需再次对其绑定

        阻止冒泡：在W3c中，使用stopPropagation（）方法

        阻止捕获：阻止事件的默认行为，使用preventDefault（）方法




    改变this指向：(5种)

        a.如果是一般函数,this指向全局对象window;
        b.在严格模式下"use strict",为undefined.
        c.对象的方法里调用,this指向调用该方法的对象.
        d.构造函数里的this,指向创建出来的实例.

        //改变this的指向并且执行调用函数
        .call()
        .call(thisScope, arg1, arg2, arg3...)

        .apply()
        apply(thisScope, [arg1, arg2, arg3...])

        //bind 改变this的指向，返回的是函数
        .bind() 
        .bind(thisScope, arg1, arg2, arg3...)

        箭头函数

        在function外面 用var that=this;来改变指向


        this总是指向函数的直接调用者（而非间接调用者）
        如果有new关键字，this指向new出来的那个对象
        在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window

    类继承

        class Person {
            //constructor关键词，是一个构造函数，相当于入口把name传进来，实例化的时候就执行了
            constructor(name){  
                this.name = name
            }
            greet(){
                return `${this.name}向你问好`;
            }
        }

        //继承
        class Student extends Person{
            constructor(name,major){
                super(name);//相当于调用父级的constructor
                this.major = major;
            }
            studentGreet(){
                return `${this.major}系的${this.name}向你问好`;
            }
        }

        let xiaoming = new Person('小明');
        console.log(xiaoming.greet())

        let S_xiaoming = new Student('小明','计算机');
        console.log(S_xiaoming.studentGreet())

    原型链继承



    高内聚，低耦合：

        内聚关注模块内部的元素结合程度，耦合关注模块之间的依赖程度。

        内聚性：
        又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量

        耦合性：
        也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差


    Ajax写法：

        原生：
```js
var Ajax={
  get: function(url, fn) {
    // XMLHttpRequest对象用于在后台与服务器交换数据   
    var xhr = new XMLHttpRequest();            
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function() {
      // readyState == 4说明请求已完成
      if (xhr.readyState == 4 && xhr.status == 200 || xhr.status == 304) { 
        // 从服务器获得数据 
        fn.call(this, xhr.responseText);  
      }
    };
    xhr.send();
  },

  // datat应为'a=a1&b=b1'这种字符串格式，在jq里如果data为对象会自动将对象转成这种字符串格式
  post: function (url, data, fn) {
    var xhr = new XMLHttpRequest();
    xhr.open("POST", url, true);
    // 添加http头，发送信息至服务器时内容编码类型
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");  
    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4 && (xhr.status == 200 || xhr.status == 304)) {
        fn.call(this, xhr.responseText);
      }
    };
    xhr.send(data);
  }
}

//  创建连接(未封装)
    var xhr = null;
    xhr = new XMLHttpRequest()
    // 2. 连接服务器
    xhr.open('get', url, true)
    // 3. 发送请求
    xhr.send(null);
    // 4. 接受请求
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4){
            if(xhr.status == 200){
                success(xhr.responseText);
            } else { // fail
                fail && fail(xhr.status);
            }
        }
    }

```

        jq：
```js
$.ajax({
    url:"http://www.xxx",//请求的url地址
    dataType:"json",//返回的格式为json
    async:true,//请求是否异步，默认true异步，这是ajax的特性
    data:{"id":"value"},//参数值
    type:"GET",//请求的方式
    beforeSend:function(){},//请求前的处理
    success:function(req){},//请求成功的处理
    complete:function(){},//请求完成的处理
    error:function(){}//请求出错的处理
});

//跨域要加个参数
$.ajax({    
    url:"http://www.xxx",//请求的url地址    
    dataType:"json",//返回的格式为json    
    async:true,//请求是否异步，默认true异步，这是ajax的特性    
    data:{"id":"value"},//参数值    
    type:"GET",//请求的方式    
    jsonp:"jsoncallback",    //这行必须写，jaoncallback默认是callback，后台传值也要把这个带上
    jsoncallback:"jsoncallback",    //这一行可以不写
    beforeSend:function(){},//请求前的处理    
    success:function(req){},//请求成功的处理    
    complete:function(){},//请求完成的处理    
    error:function(){}//请求出错的处理
});
```

    axios
    是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中
```js
//get请求
// 为给定 ID 的 user 创建请求
axios.get('/user?ID=12345')
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });

// 可选地，上面的请求可以这样做
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });


  //post请求
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });

  

```
        

    优雅降级、渐进增强

        渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

        优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

        区别：
    　　优雅降级是从复杂的现状开始，并试图减少用户体验的供给，
    　　而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。
    　　降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。

        写法：
            .transition { /*渐进增强写法*/
             -webkit-transition: all .5s;
                -moz-transition: all .5s;
                  -o-transition: all .5s;
                     transition: all .5s;
            }
            .transition { /*优雅降级写法*/
                     transition: all .5s;
                  -o-transition: all .5s;
                -moz-transition: all .5s;
             -webkit-transition: all .5s;
            }

    三大框架优缺点：(avalon也是MVVM框架)

|#        |Angular  |React    |Vue      |
|:-------:|:-------:|:-------:|:-------:|
|组织方式  |MVVM     |模块化    |模块化（MVVM）|
|数据绑定  |双向绑定  |单向绑定  |双向绑定      |
|模板能力  |强大      |自由     |自由       |
|自由度    |较小     |大        |较大       |
|路由      |静态     |动态路由  |动态路由   |

    Vue.js
    一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 Filters

    AngularJS
    是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令

    react
    React 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好。


    MVVM的优点
    低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；

    可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；

    独立开发：开发人员可以专注与业务逻辑和数据的开发 
    ViewModemvvm设计人员可以专注于UI(View)的设计；

    可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。



    ES5\ES6 新增了哪些新特性
        关于对象实例的属性，每一个实例都有两种属性，一种是实例属性,一种是原型属性

        ES5：
            严格模式( use strict )
            新增API
                Date.now()
                trim()
            新增内置对象：
                JSON.stringify() -- 将JS值转换为JSON文本格式的字符串
                JSON.parse() -- 将JSON文本转换为 JS 值
            新增Function接口
                Function.prototype.bind
                bind()方法会创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this,传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。


        ES6：
            模板字符串
            块级作用域
            箭头函数
            解构赋值
            模块导入/导出
            类 (Class)
            继承
            数组的展开运算（数组前加...）

    项目中遇到过哪些难题 ？ 如何解决



    在你的项目中进行了哪些优化？


    HTML5的离线存储机制

        原理：

        HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

        
        <!DOCTYPE HTML>
        <html manifest = "cache.manifest">
            ...
        </html>



    Http 和 Https 的区别（常考）
        Http 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同：
        端口不同：Http 与 Http 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443；
        资源消耗：和 HTTP 通信相比，Https 通信会由于加减密处理消耗更多的 CPU 和内存资源；
        开销：Https 通信需要证书，而证书一般需要向认证机构购买；
        Https 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

    IP 地址分为 A,B,C,D,E 五类。

        网络号：用于识别主机所在的网络； 主机号：用于识别该网络中的主机。

        其中 A 类分配给政府机关使用，B 类地址给大中型企业使用，C 类地址给个人使用。这三种是主要的。

        IP 地址分为五类，A 类保留给政府机构，B 类分配给中等规模的公司，C 类分配给任何需要的人，D 类用于组播，E 类用于实验，各类可容纳的地址数目不同。

        其中 A 类、B 类、和 C 类这三类地址用于 TCP/IP 节点，其它两类 D 类和 E 类被用于特殊用途。 A、B、C 三类 IP 地址的特征：当将 IP 地址写成二进制形式时，A 类地址的第一位总是 O，B 类地址的前两位总是 10，C 类地址的前三位总是 110。


    富文本编辑器采用vue-quill-editor


    Fetch数据请求


    小程序都用了哪些接口（API）
        


    反问：

    某个技术是什么，在工作中的使用情况，或者在哪些方面使用


101. 某些福利条件签约（三年） 不签






