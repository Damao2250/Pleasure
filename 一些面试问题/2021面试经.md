## html

## css

## http

## ajax
+ ajax轮询的原理：让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息
```js
let xmlhttp=new XMLHttpRequest()
xmlhttp.onreadystatechange(()=>{ //每当 readyState 属性改变时，就会调用该函数
     if (xmlhttp.readyState==4 && xmlhttp.status==200){
        // readyState -> 0: 请求未初始化; 1: 服务器连接已建立; 2: 请求已接收; 3: 请求处理中; 4: 请求已完成，且响应已就绪
        // status -> 200: "OK"; 404: 未找到页面; ...
        console.log(xmlhttp.responseText) // 响应内容
        ...
     }
 })
xmlhttp.open() // 规定请求的类型、URL 以及是否异步处理请求； open(method,url,async(布尔值，是否异步))
xmlhttp.send() // 将请求发送到服务器
```

## axios、fetch

## vue

## vue3
+ 新的虚拟Dom的diff算法
+ Proxy代替defineProperty的getter/setter     
+ setup函数
+ composition Api


## vue-router
+ router.beforeEach 全局前置守卫 进入路由之前
+ router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用
+ router.afterEach 全局后置钩子 进入路由之后

+ 全局前置/钩子：beforeEach、beforeResolve、afterEach
+ 路由独享的守卫：beforeEnter
+ 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

## vuex
+ State
    - mapState
+ Getter
    - mapGetters
+ Mutation (必须是同步函数)
    - mapMutations
+ Action
    - mapActions
    - `Action`也可以通过 `store.dispatch` 方法触发
+ Module
    - 个模块拥有自己的 state、mutation、action、getter
## element-ui

## 小程序

## react

## redux
+ Store
    - 维持应用的 state；
    - 提供 store.getState() 方法从store获取 state；
    - 提供 dispatch(action) 方法更新 state；
    - 通过 subscribe(listener) 注册监听器;
    - 通过 subscribe(listener) 返回的函数注销监听器；
+ state
    - 当前时刻的 State，可以通过store.getState()拿到
    - 一个 State 对应一个 View。只要 State 相同，View 就相同
+ Action
    - 会通过 store.dispatch() 将 action 传到 store
    - Action 就是 View 发出的通知，表示 State 应该要发生变化了
    - actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state
    - 改变 State 的唯一办法，就是使用 Action
+ Reducer
    - Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的
    - Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State
+ Store里有state, view要改变state，就要让action通知reducre去改变state
## js
+ 浅拷贝的方法
    1. Object.assign()
    2. Array.prototype.concat()
    3. Array.prototype.slice()
    4. lodash.clone
+ 深拷贝方法
    1. JSON.parse(JSON.stringify()) -> 缺陷: 可以实现对象或数组的深拷贝，但是不能处理函数、正则、日期
    1. lodash.cloneDeep

## es6
+ let const
+ 扩展字符串
+ 字符串模板
+ sb
+ 

## typescript

## nginx

## webpack

## babel

## 浏览器缓存

## 网络优化、性能优化

## cicd

## docker、k8s

## vue、react、小程序生命周期
### vue
+ beforeCreate
+ created
+ beforeMount
+ mounted
+ beforeUpdate
+ updated
+ beforeDestroy
+ destroyed
+ errorCaptured
### vue3
+ beforeCreate -> use setup()
+ created -> use setup()
+ beforeMount -> onBeforeMount
+ mounted -> onMounted
+ beforeUpdate -> onBeforeUpdate
+ updated -> onUpdated
+ beforeDestroy -> onBeforeUnmount
+ destroyed -> onUnmounted
+ errorCaptured -> onErrorCaptured

### react
+ 三个阶段：
    + 初始化（挂载）阶段: 由 ReactDOM.render() 触发——初次渲染
        + constructor()
        + componentWillMount()
        + render() =====> 必须使用的一个
        + componentDidMount() =====> 常用
        + 一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息
    + 更新阶段: 由组件内部 this.setSate() 或 父组件render 触发
        + shouldComponentUpdate()
        + componentWillUpdate()
        + render() =====> 必须使用的一个
        + componentDidUpdate()
    + 卸载组件: 由 ReactDOM.unmountComponentAtNode() 触发
        + componentWillUnmount() =====> 常用
        + 一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息
+ react15
    - constructor()
    - componentWillReceiveProps()
    - shouldComponentUpdate()
    - componentWillMount()
    - componentWillUpdate()
    - componentDidUpdate()
    - componentDidMount
    - render()
    - componentWillUnmount()
+ react16
    - constructor()
    - componentWillReceiveProps()
    - shouldComponentUpdate()
    - <!-- - componentWillMount() -->
    - getDerivedStateFromProps
    - componentWillUpdate()
    - componentDidUpdate()
    - componentDidMount
    - render()
    - componentWillUnmount()
### 小程序
+ onLond
+ onShow
+ onReady
+ onHide
+ onUnload

+ onPullDownRefresh

## 网络安全
+ web安全常见攻击手段
    - xss(cross site scripting) 跨站脚本攻击

## WebSocket
+ WebSocket是HTML5出的一个持久化的协议
+ 只要客户端发起一次http请求后，服务器就可以源源不断的给客户端回调
+ 创建连接：var Socket = new WebSocket(url, [protocol] );
+ 连接状态：Socket.readyState
    - CONNECTING：值为0，表示正在连接。
    - OPEN：值为1，表示连接成功，可以通信了。
    - CLOSING：值为2，表示连接正在关闭。
    - CLOSED：值为3，表示连接已经关闭，或者打开连接失败。
+ WebSocket 事件
    + open	Socket.onopen	连接建立时触发
    + message	Socket.onmessage	客户端接收服务端数据时触发
    + error	Socket.onerror	通信发生错误时触发
    + close	Socket.onclose	连接关闭时触发
+ WebSocket 方法
    - Socket.send()   使用连接发送数据
    - Socket.close()	关闭连接

## http1 http2

## TCP连接


## 自我介绍
你好，我叫xxx，
我目前用的比较的技术栈是vue跟微信小程序这块
我的之前公司中做的项目类型主要是以后台管理系统、大屏数据展示、小程序、H5页面为主。

我之前在中科汇智主要是以一个小组长的身份负责技术的选型评审，以及负责整个公司的代码仓库的搭建和部署，当时是用了gitlab的社区版

平时也会在掘金、简书、GitHub上学一些知识，也会在GitHub上更新自己的一些博客还有一些学习的总结

一开始小程序选择taro后来换成uniapp（react、vue、社区活跃度，组件丰富度）

发票查验系统。兼容银行的一些老电脑选项jq，后来改为vue，向下兼容到ie11，大部分功能向下兼容到ie10


国际贸易电子化结算系统
ASOne 网申助手
汇智运管家
绿色港口
发票查验系统
粤港澳大湾区区块链可视化平台

技术主要还是围绕vue vue-router vuex axios echarts elementui andt ts taro uniapp
canvas标注



