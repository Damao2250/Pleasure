# HTTP相关

## HTTP 请求方法
|方法|描述|
|:---------|:-------------------------------------------
|GET        |从指定的资源请求数据。
|POST       |向指定的资源提交要被处理的数据。
|HEAD	    |与 GET 相同，但只返回 HTTP 报头，不返回文档主体。
|PUT	    |上传指定的 URI 表示。
|DELETE	    |删除指定资源。
|OPTIONS    |返回服务器支持的 HTTP 方法。
|CONNECT	|把请求连接转换到透明的 TCP/IP 通道。
|||

get&&post区别
|Get                                |Post                                       |
|:--------------------------------|:------------------------------------------|
|:GET 请求可被缓存                    |:       POST 请求不会被缓存              |
|GET 请求保留在浏览器历史记录中      |          POST 请求不会保留在浏览器历史记录中|
|GET 请求可被收藏为书签             |           POST 不能被收藏为书签              |
|GET 请求不应在处理敏感数据时使用   |                                               |
|GET 请求有长度限制 （2048字符）   |            POST 请求对数据长度没有要求         |
|GET 请求只应当用于取回数据         |                                       |
|||

+ 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！
+ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。

## HTTP状态消息

### 1xx: 信息
|消息                           |描述|
|:------------------------------|:-------------------------------------------
|100 Continue                   |服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。
|101 Switching Protocols        |服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。
|103 Checkpoint	                |用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。
|||

### 2xx: 信息
|消息                                   |描述|
|:--------------------------------------|:-------------------------------------------
|200 OK                                 |请求成功（这是对HTTP请求成功的标准应答。）
|201 Created                            |请求被创建完成，同时新的资源被创建。
|202 Accepted	                        |供处理的请求已被接受，但是处理未完成。
|203 Non-Authoritative Information	    |请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。
|204 No Content	                        |请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。
|205 Reset Content                      |请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。
|206 Partial Content	                |客户发送了一个带有Range头的GET请求，服务器完成了它。
|||

### 3xx: 信息
|消息                   |描述|
|:----------------------|:-------------------------------------------
|300 Multiple Choices	|多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。
|301 Moved Permanently	|所请求的页面已经转移至新的 URL 。
|302 Found	            |所请求的页面已经临时转移至新的 URL 。
|303 See Other	        |所请求的页面可在别的 URL 下被找到。
|304 Not Modified	    |未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
|305 Use Proxy	        |客户请求的文档应该通过Location头所指明的代理服务器提取。
|306 Switch Proxy	    |目前已不再使用，但是代码依然被保留。
|307 Temporary Redirect	|被请求的页面已经临时移至新的 URL 。
|308 Resume Incomplete	|用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。
|||

### 4xx: 信息
|消息                                   |描述|
|:--------------------------------------|:-------------------------------------------
|400 Bad Request	                    |因为语法错误，服务器未能理解请求。
|401 Unauthorized	                    |合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。
|402 Payment Required	                |此代码尚无法使用。
|403 Forbidden	                        |合法请求，但对被请求页面的访问被禁止。
|404 Not Found	                        |服务器无法找到被请求的页面。
|405 Method Not Allowed	                |请求中指定的方法不被允许。
|406 Not Acceptable	                    |服务器生成的响应无法被客户端所接受。
|407 Proxy Authentication Required	    |用户必须首先使用代理服务器进行验证，这样请求才会被处理。
|408 Request Timeout	                |请求超出了服务器的等待时间。
|409 Conflict	                        |由于冲突，请求无法被完成。
|410 Gone	                            |被请求的页面不可用。
|411 Length Required	                |"Content-Length" 未被定义。如果无此内容，服务器不会接受请求。
|412 Precondition Failed	            |请求中的前提条件被服务器评估为失败。
|413 Request Entity Too Large	        |由于所请求的实体太大，服务器不会接受请求。
|414 Request-URI Too Long	            |由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。
|415 Unsupported Media Type	            |由于媒介类型不被支持，服务器不会接受请求。
|416 Requested Range Not Satisfiable	|客户端请求部分文档，但是服务器不能提供被请求的部分。
|417 Expectation Failed	                |服务器不能满足客户在请求中指定的请求头。
|||

# html+css
+ H5常见新增元素
    `<article> <aside> <figure> <footer> <header> <nav> <time> <dialog> <mark> <details>`
    语义元素
    `<header> <nav> <section> <article> <aside> <figcaption> <figure> <footer>`

### 5xx: 信息
|消息                                       |描述|
|:------------------------------------------|:-------------------------------------------
|500 Internal Server Error	                |请求未完成。服务器遇到不可预知的情况。
|501 Not Implemented	                    |请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。
|502 Bad Gateway	                        |请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。
|503 Service Unavailable	                |服务器当前不可用（过载或者当机）。
|504 Gateway Timeout	                    |网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。
|505 HTTP Version Not Supported	            |服务器不支持请求中指明的HTTP协议版本。
|511 Network Authentication Required	    |用户需要提供身份验证来获取网络访问入口。
|||

---

# vue

## 1. MVVM理解

    MVVM 是 Model-View-ViewModel 的缩写

    + Model 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。

    + View 代表UI 组件，它负责将数据模型转化成UI 展现出来。

    + ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。

    在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。

    ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

    View <-> ViewModel <=> Model

## 2. Vue的生命周期(8个)

    + beforeCreate（创建前），在数据观测和初始化事件还未开始

    + created（创建后），完成数据观测，属性和方法的运算，初始化事件， $el 属性还没有显示出来

    + beforeMount（载入前），在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。

    + mounted（载入后），在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。

    + pbeforeUpdate（更新前），在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。

    + updated（更新后），在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

    + beforeDestroy（销毁前），在实例销毁之前调用。实例仍然完全可用。

    + destroyed（销毁后），在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

    1. 什么是vue生命周期？

        答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。

    2. vue生命周期的作用是什么？

        答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

    3. vue生命周期总共有几个阶段？

        答：它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。

    4. 第一次页面加载会触发哪几个钩子？

        答：会触发下面这几个beforeCreate、created、beforeMount、mounted 。

    5. DOM 渲染在哪个周期中就已经完成？

        答：DOM 渲染在 mounted 中就已经完成了。



## 3. Vue实现数据双向绑定的原理：`Object.defineProperty()`

    `Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

    vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 `Object.defineProperty()` 来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 `Object.defineProperty()` 将它们转为 `getter/setter`。用户看不到 `getter/setter`，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

    vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。

js实现简单的双向绑定：

```js
<body>
    <div id="app">  
        <input type="text" id="txt">
        <p id="show"></p>
    </div>
</body>

<script type="text/javascript">  
    var obj = {}   
    Object.defineProperty(obj, 'txt', {       
        get: function() {
            return obj
        },
        set: function(newValue) {
                document.getElementById('txt').value = newValue
                document.getElementById('show').innerHTML = newValue
            }
    })
    document.addEventListener('keyup', function(e) {
        obj.txt = e.target.value
    })
</script>
```

## 4. Vue组件间的参数传递

    1、父组件与子组件传值

    父组件传给子组件：子组件通过props方法接受数据；

    子组件传给父组件： $emit 方法传递参数

    2、非父子组件间的数据传递，兄弟组件传值

    eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道）。

## 5. Vue的路由实现：hash模式 和 history模式

    hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。

    history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。

## 6. 六、Vue与Angular以及React的区别？
    版本在不断更新，以下的区别有可能不是很正确。我工作中只用到vue，对angular和react不怎么熟。

1. 与AngularJS的区别

    相同点：都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。

    不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。

2. 与React的区别

    相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。

    不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。

## 7. vue路由的钩子函数

首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。

+ beforeEach主要有3个参数to，from，next。

+ to：route即将进入的目标路由对象。

+ from：route当前导航正要离开的路由。

+ next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。


## 8. vuex是什么？怎么使用？哪种功能场景使用它？

    只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。

    在main.js引入store，注入。新建了一个目录store，… export 。

    场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车

Vuex示图
```js
                           `Backend API`
                               ^                Vuex
                        -------|-----------------------------
            Dispath    |       v            Commit           |
        ---------------|-->`Actions` ---------------         |
        |              |                            |        |
        |              |                            v        |
`Vue Components`       |                        `Mutate` <---|--> `Devtool`
        ^              |                            |        |
        |              |                            |        |
        ---------------|---`State`<------------------        |
            Render     |                    Mutate           |
                        -------------------------------------
```

    state：Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。

    mutations：mutations定义的方法动态修改Vuex 的 store 中的状态或数据。

    getters：类似vue的计算属性，主要用来过滤一些数据。

    action：actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。

```js
const store = new Vuex.Store({ 
//store实例
    state: {
        count: 0
        },
    mutations: {                
        increment (state) {
            state.count++
        }
        },
    actions: { 
        increment (context) {
            context.commit('increment')
        }
    }
})

```
    modules：项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理。

```js

const moduleA = {
    state: { ... },
    mutations: { ... },
    actions: { ... },
    getters: { ... }
}

const moduleB = {
    state: { ... },
    mutations: { ... },
    actions: { ... },
    getters: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
})
```

## 9. 其他
    1、css只在当前组件起作用

    答：在style标签中写入scoped即可 例如： <stylescoped></style>

    2、v-if 和 v-show 区别

    答：v-if按照条件是否渲染，v-show是display的block或none；

    3、$route和$router的区别

    答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。

